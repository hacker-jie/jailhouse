From 49b3b33c1338a59fd333c69fffbff813990f8042 Mon Sep 17 00:00:00 2001
From: Jan Kiszka <jan.kiszka@siemens.com>
Date: Mon, 27 Jul 2020 08:50:12 +0200
Subject: [PATCH 01/11] arm-common: Reorder gicv2_cpu_init

This pulls CPU ID validation and gicv2_target_cpu_map setup to the
beginning of gicv2_cpu_init so that we can fail early if needed, before
any changes to the hardware configuration are made. This will also help
when introducing SDEI-based management interrupts.

Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
---
 hypervisor/arch/arm-common/gic-v2.c | 36 ++++++++++++++---------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/hypervisor/arch/arm-common/gic-v2.c b/hypervisor/arch/arm-common/gic-v2.c
index 4b69f74b..6a86ca8c 100644
--- a/hypervisor/arch/arm-common/gic-v2.c
+++ b/hypervisor/arch/arm-common/gic-v2.c
@@ -102,6 +102,24 @@ static int gicv2_cpu_init(struct per_cpu *cpu_data)
 	u32 cell_gicc_ctlr, cell_gicc_pmr;
 	unsigned int n;
 
+	/*
+	 * Get the CPU interface ID for this cpu. It can be discovered by
+	 * reading the banked value of the PPI and IPI TARGET registers
+	 * Patch 2bb3135 in Linux explains why the probe may need to scans the
+	 * first 8 registers: some early implementation returned 0 for the first
+	 * ITARGETSR registers.
+	 * Since those didn't have virtualization extensions, we can safely
+	 * ignore that case.
+	 */
+	if (cpu_data->public.cpu_id >= ARRAY_SIZE(gicv2_target_cpu_map))
+		return trace_error(-EINVAL);
+
+	gicv2_target_cpu_map[cpu_data->public.cpu_id] =
+		mmio_read32(gicd_base + GICD_ITARGETSR);
+
+	if (gicv2_target_cpu_map[cpu_data->public.cpu_id] == 0)
+		return trace_error(-ENODEV);
+
 	/* Ensure all IPIs and the maintenance PPI are enabled. */
 	mmio_write32(gicd_base + GICD_ISENABLER, 0x0000ffff | (1 << mnt_irq));
 
@@ -146,24 +164,6 @@ static int gicv2_cpu_init(struct per_cpu *cpu_data)
 
 	cpu_data->public.gicc_initialized = true;
 
-	/*
-	 * Get the CPU interface ID for this cpu. It can be discovered by
-	 * reading the banked value of the PPI and IPI TARGET registers
-	 * Patch 2bb3135 in Linux explains why the probe may need to scans the
-	 * first 8 registers: some early implementation returned 0 for the first
-	 * ITARGETSR registers.
-	 * Since those didn't have virtualization extensions, we can safely
-	 * ignore that case.
-	 */
-	if (cpu_data->public.cpu_id >= ARRAY_SIZE(gicv2_target_cpu_map))
-		return trace_error(-EINVAL);
-
-	gicv2_target_cpu_map[cpu_data->public.cpu_id] =
-		mmio_read32(gicd_base + GICD_ITARGETSR);
-
-	if (gicv2_target_cpu_map[cpu_data->public.cpu_id] == 0)
-		return trace_error(-ENODEV);
-
 	/*
 	 * Forward any pending physical SGIs to the virtual queue.
 	 * We will convert them into self-inject SGIs, ignoring the original
-- 
2.34.1

